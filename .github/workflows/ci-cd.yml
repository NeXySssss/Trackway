name: CI-CD

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

concurrency:
  group: trackway-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  packages: write

jobs:
  test:
    name: Test and Build
    runs-on:
      - self-hosted
      - Linux
      - X64
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache: true

      - name: Run tests
        run: go test ./...

      - name: Build
        run: go build ./...

  image:
    name: Build and Push Image
    runs-on:
      - self-hosted
      - Linux
      - X64
    needs:
      - test
    if: github.event_name != 'pull_request' && github.ref == 'refs/heads/main'
    outputs:
      image_latest: ${{ steps.meta.outputs.image_latest }}
      image_sha: ${{ steps.meta.outputs.image_sha }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Derive image names
        id: meta
        run: |
          set -euo pipefail
          owner_lower="$(echo "${GITHUB_REPOSITORY_OWNER}" | tr '[:upper:]' '[:lower:]')"
          image_base="ghcr.io/${owner_lower}/trackway"
          image_sha="${image_base}:${GITHUB_SHA}"
          image_latest="${image_base}:latest"
          echo "image_sha=${image_sha}" >> "${GITHUB_OUTPUT}"
          echo "image_latest=${image_latest}" >> "${GITHUB_OUTPUT}"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ steps.meta.outputs.image_sha }}
            ${{ steps.meta.outputs.image_latest }}

  deploy:
    name: Deploy over SSH
    runs-on:
      - self-hosted
      - Linux
      - X64
    needs:
      - image
    if: github.event_name != 'pull_request' && github.ref == 'refs/heads/main'
    env:
      DEPLOY_DIR: /opt/trackway
      BACKUP_DIR: /opt/trackway/backups
      TRACKWAY_CONFIG_PATH: /opt/trackway/config.yaml
      COMPOSE_PROJECT_NAME: trackway
      BACKUP_KEEP: "30"
      TRACKWAY_IMAGE: ${{ needs.image.outputs.image_latest }}
      TRACKWAY_BIND_IP: ${{ secrets.TRACKWAY_BIND_IP || '127.0.0.1' }}
      TRACKWAY_BIND_PORT: ${{ secrets.TRACKWAY_BIND_PORT || '8083' }}
      CLICKHOUSE_ADDR: ${{ secrets.CLICKHOUSE_ADDR || 'clickhouse:9000' }}
      CLICKHOUSE_DB: ${{ secrets.CLICKHOUSE_DB || 'trackway' }}
      CLICKHOUSE_USER: ${{ secrets.CLICKHOUSE_USER || 'default' }}
      CLICKHOUSE_PASSWORD: ${{ secrets.CLICKHOUSE_PASSWORD }}

      DEPLOY_SSH_HOST: ${{ secrets.DEPLOY_SSH_HOST || secrets.SSH_HOST }}
      DEPLOY_SSH_USER: ${{ secrets.DEPLOY_SSH_USER || secrets.SSH_USER || 'deploy' }}
      DEPLOY_SSH_PORT: ${{ secrets.DEPLOY_SSH_PORT || secrets.SSH_PORT || '22' }}
      DEPLOY_SSH_PRIVATE_KEY: ${{ secrets.DEPLOY_SSH_PRIVATE_KEY || secrets.SSH_PRIVATE_KEY }}
      DEPLOY_SSH_KNOWN_HOSTS: ${{ secrets.DEPLOY_SSH_KNOWN_HOSTS || secrets.SSH_KNOWN_HOSTS }}

      GHCR_USERNAME: ${{ github.actor }}
      GHCR_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      TRACKWAY_CONFIG_YAML: ${{ secrets.TRACKWAY_CONFIG_YAML }}
      TRACKWAY_CONFIG_JSON: ${{ secrets.TRACKWAY_CONFIG_JSON }}
      TRACKWAY_CONFIG_JSON_B64: ${{ secrets.TRACKWAY_CONFIG_JSON_B64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate required secrets
        run: |
          set -euo pipefail
          if [ -z "${DEPLOY_SSH_HOST}" ]; then
            echo "Secret DEPLOY_SSH_HOST is required." >&2
            exit 1
          fi
          if [ -z "${DEPLOY_SSH_USER}" ]; then
            echo "Secret DEPLOY_SSH_USER is required." >&2
            exit 1
          fi
          if [ -z "${DEPLOY_SSH_PRIVATE_KEY}" ]; then
            echo "Secret DEPLOY_SSH_PRIVATE_KEY is required." >&2
            exit 1
          fi
          if [ -z "${GHCR_USERNAME}" ]; then
            echo "GHCR username is empty (github.actor)." >&2
            exit 1
          fi
          if [ -z "${GHCR_TOKEN}" ]; then
            echo "GITHUB_TOKEN is empty." >&2
            exit 1
          fi
          if [ -z "${CLICKHOUSE_ADDR}" ]; then
            echo "CLICKHOUSE_ADDR is empty." >&2
            exit 1
          fi
          if [ -z "${CLICKHOUSE_DB}" ]; then
            echo "CLICKHOUSE_DB is empty." >&2
            exit 1
          fi
          if [ -z "${CLICKHOUSE_USER}" ]; then
            echo "CLICKHOUSE_USER is empty." >&2
            exit 1
          fi

      - name: Setup SSH key
        run: |
          set -euo pipefail
          mkdir -p "${HOME}/.ssh"
          chmod 700 "${HOME}/.ssh"
          printf '%s\n' "${DEPLOY_SSH_PRIVATE_KEY}" > "${HOME}/.ssh/id_trackway_deploy"
          chmod 600 "${HOME}/.ssh/id_trackway_deploy"

      - name: Setup known_hosts
        run: |
          set -euo pipefail
          port="${DEPLOY_SSH_PORT:-22}"
          if [ -n "${DEPLOY_SSH_KNOWN_HOSTS}" ]; then
            printf '%s\n' "${DEPLOY_SSH_KNOWN_HOSTS}" >> "${HOME}/.ssh/known_hosts"
          else
            ssh-keyscan -H -p "${port}" "${DEPLOY_SSH_HOST}" >> "${HOME}/.ssh/known_hosts"
          fi
          chmod 644 "${HOME}/.ssh/known_hosts"

      - name: Ensure remote directories
        run: |
          set -euo pipefail
          port="${DEPLOY_SSH_PORT:-22}"
          ssh -i "${HOME}/.ssh/id_trackway_deploy" -p "${port}" \
            -o BatchMode=yes -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes \
            "${DEPLOY_SSH_USER}@${DEPLOY_SSH_HOST}" \
            "mkdir -p '${DEPLOY_DIR}' '${BACKUP_DIR}'"

      - name: Sync repo to server
        run: |
          set -euo pipefail
          port="${DEPLOY_SSH_PORT:-22}"
          rsync -az --delete \
            --exclude '.git' \
            --exclude 'config.yaml' \
            --exclude 'backups/' \
            -e "ssh -i ${HOME}/.ssh/id_trackway_deploy -p ${port} -o BatchMode=yes -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes" \
            "${GITHUB_WORKSPACE}/" "${DEPLOY_SSH_USER}@${DEPLOY_SSH_HOST}:${DEPLOY_DIR}/"

      - name: Write runtime config from secret (optional)
        if: ${{ env.TRACKWAY_CONFIG_YAML != '' }}
        run: |
          set -euo pipefail
          port="${DEPLOY_SSH_PORT:-22}"
          config_b64="$(printf '%s' "${TRACKWAY_CONFIG_YAML}" | base64 -w0)"
          ssh -i "${HOME}/.ssh/id_trackway_deploy" -p "${port}" \
            -o BatchMode=yes -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes \
            "${DEPLOY_SSH_USER}@${DEPLOY_SSH_HOST}" \
            "umask 022 && printf '%s' '${config_b64}' | base64 -d > '${TRACKWAY_CONFIG_PATH}' && chmod 0644 '${TRACKWAY_CONFIG_PATH}'"

      - name: Deploy on server
        run: |
          set -euo pipefail
          port="${DEPLOY_SSH_PORT:-22}"

          ghcr_user_b64="$(printf '%s' "${GHCR_USERNAME}" | base64 -w0)"
          ghcr_token_b64="$(printf '%s' "${GHCR_TOKEN}" | base64 -w0)"
          clickhouse_addr_b64="$(printf '%s' "${CLICKHOUSE_ADDR}" | base64 -w0)"
          clickhouse_db_b64="$(printf '%s' "${CLICKHOUSE_DB}" | base64 -w0)"
          clickhouse_user_b64="$(printf '%s' "${CLICKHOUSE_USER}" | base64 -w0)"
          clickhouse_password_b64="$(printf '%s' "${CLICKHOUSE_PASSWORD}" | base64 -w0)"
          runtime_config_json_b64="${TRACKWAY_CONFIG_JSON_B64}"
          if [ -z "${runtime_config_json_b64}" ] && [ -n "${TRACKWAY_CONFIG_JSON}" ]; then
            runtime_config_json_b64="$(printf '%s' "${TRACKWAY_CONFIG_JSON}" | base64 -w0)"
          fi

          ssh -i "${HOME}/.ssh/id_trackway_deploy" -p "${port}" \
            -o BatchMode=yes -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes \
            "${DEPLOY_SSH_USER}@${DEPLOY_SSH_HOST}" \
            "DEPLOY_DIR='${DEPLOY_DIR}' BACKUP_DIR='${BACKUP_DIR}' TRACKWAY_CONFIG_PATH='${TRACKWAY_CONFIG_PATH}' COMPOSE_PROJECT_NAME='${COMPOSE_PROJECT_NAME}' BACKUP_KEEP='${BACKUP_KEEP}' TRACKWAY_IMAGE='${TRACKWAY_IMAGE}' TRACKWAY_BIND_IP='${TRACKWAY_BIND_IP}' TRACKWAY_BIND_PORT='${TRACKWAY_BIND_PORT}' GHCR_USER_B64='${ghcr_user_b64}' GHCR_TOKEN_B64='${ghcr_token_b64}' CLICKHOUSE_ADDR_B64='${clickhouse_addr_b64}' CLICKHOUSE_DB_B64='${clickhouse_db_b64}' CLICKHOUSE_USER_B64='${clickhouse_user_b64}' CLICKHOUSE_PASSWORD_B64='${clickhouse_password_b64}' TRACKWAY_CONFIG_JSON_B64='${runtime_config_json_b64}' bash -se" <<'REMOTE'
          set -euo pipefail

          decode_b64() {
            printf '%s' "$1" | base64 -d
          }

          ghcr_user="$(decode_b64 "${GHCR_USER_B64}")"
          ghcr_token="$(decode_b64 "${GHCR_TOKEN_B64}")"
          clickhouse_addr="$(decode_b64 "${CLICKHOUSE_ADDR_B64}")"
          clickhouse_db="$(decode_b64 "${CLICKHOUSE_DB_B64}")"
          clickhouse_user="$(decode_b64 "${CLICKHOUSE_USER_B64}")"
          clickhouse_password="$(decode_b64 "${CLICKHOUSE_PASSWORD_B64}")"
          runtime_config_json_b64="${TRACKWAY_CONFIG_JSON_B64}"

          if [ -z "${runtime_config_json_b64}" ] && [ ! -s "${TRACKWAY_CONFIG_PATH}" ]; then
            echo "No runtime config provided and file is missing: ${TRACKWAY_CONFIG_PATH}" >&2
            echo "Set TRACKWAY_CONFIG_JSON(_B64) secret or provide config.yaml on server." >&2
            exit 1
          fi
          if [ -n "${runtime_config_json_b64}" ] && [ ! -e "${TRACKWAY_CONFIG_PATH}" ]; then
            mkdir -p "$(dirname "${TRACKWAY_CONFIG_PATH}")"
            : > "${TRACKWAY_CONFIG_PATH}"
            chmod 0644 "${TRACKWAY_CONFIG_PATH}"
          fi

          export DOCKER_CONFIG="/tmp/trackway-docker-auth"
          cleanup_docker_auth() {
            rm -rf "${DOCKER_CONFIG}"
          }
          trap cleanup_docker_auth EXIT
          rm -rf "${DOCKER_CONFIG}"
          mkdir -p "${DOCKER_CONFIG}"
          printf '%s' "${ghcr_token}" | docker --config "${DOCKER_CONFIG}" login ghcr.io -u "${ghcr_user}" --password-stdin

          compose_with_env() {
            TRACKWAY_BIND_IP="${TRACKWAY_BIND_IP}" TRACKWAY_BIND_PORT="${TRACKWAY_BIND_PORT}" CLICKHOUSE_ADDR="${clickhouse_addr}" CLICKHOUSE_DB="${clickhouse_db}" CLICKHOUSE_USER="${clickhouse_user}" CLICKHOUSE_PASSWORD="${clickhouse_password}" TRACKWAY_IMAGE="${TRACKWAY_IMAGE}" TRACKWAY_CONFIG_JSON_B64="${runtime_config_json_b64}" docker --config "${DOCKER_CONFIG}" compose \
              --project-name "${COMPOSE_PROJECT_NAME}" \
              -f "${DEPLOY_DIR}/docker-compose.yml" "$@"
          }

          wait_clickhouse_healthy() {
            clickhouse_container="$(compose_with_env ps -q clickhouse)"
            if [ -z "${clickhouse_container}" ]; then
              echo "Failed to resolve clickhouse container id." >&2
              compose_with_env logs --tail=200 clickhouse
              return 1
            fi

            clickhouse_ready=0
            for _ in $(seq 1 90); do
              health_status="$(docker inspect --format '{{if .State.Health}}{{.State.Health.Status}}{{else}}no-healthcheck{{end}}' "${clickhouse_container}" 2>/dev/null || echo unknown)"
              if [ "${health_status}" = "healthy" ]; then
                clickhouse_ready=1
                break
              fi
              if [ "${health_status}" = "unhealthy" ] || [ "${health_status}" = "exited" ] || [ "${health_status}" = "dead" ]; then
                echo "ClickHouse is ${health_status}." >&2
                compose_with_env ps
                compose_with_env logs --tail=200 clickhouse
                return 1
              fi
              sleep 2
            done

            if [ "${clickhouse_ready}" -ne 1 ]; then
              echo "ClickHouse did not become healthy in time." >&2
              compose_with_env ps
              compose_with_env logs --tail=200 clickhouse
              return 1
            fi
            return 0
          }

          validate_clickhouse_auth() {
            if [ -n "${clickhouse_password}" ]; then
              docker exec "${clickhouse_container}" clickhouse-client \
                --host=127.0.0.1 \
                --user="${clickhouse_user}" \
                --password="${clickhouse_password}" \
                --query="SELECT 1" >/dev/null 2>&1
              return
            fi
            docker exec "${clickhouse_container}" clickhouse-client \
              --host=127.0.0.1 \
              --user="${clickhouse_user}" \
              --query="SELECT 1" >/dev/null 2>&1
          }

          if ! bash "${DEPLOY_DIR}/scripts/backup-clickhouse.sh" "${DEPLOY_DIR}" "${BACKUP_DIR}"; then
            echo "WARNING: ClickHouse backup failed; continuing deployment." >&2
          fi

          compose_with_env up -d --force-recreate clickhouse
          wait_clickhouse_healthy

          if ! validate_clickhouse_auth; then
            echo "ClickHouse auth check failed for user='${clickhouse_user}' db='${clickhouse_db}'." >&2
            compose_with_env ps
            compose_with_env logs --tail=200 clickhouse
            exit 1
          fi

          compose_with_env pull trackway
          compose_with_env up -d trackway --remove-orphans

          sleep 5
          trackway_container="$(compose_with_env ps -q trackway)"
          if [ -z "${trackway_container}" ]; then
            echo "Trackway container id not found after deploy." >&2
            compose_with_env ps
            compose_with_env logs --tail=120 trackway
            exit 1
          fi
          trackway_state="$(docker inspect --format '{{.State.Status}}' "${trackway_container}" 2>/dev/null || echo unknown)"
          if [ "${trackway_state}" != "running" ]; then
            echo "Trackway container is not running after deploy (state=${trackway_state})." >&2
            compose_with_env ps
            compose_with_env logs --tail=120 trackway
            exit 1
          fi
          echo "Deployment completed. Trackway container is running."
          exit 0
          REMOTE
