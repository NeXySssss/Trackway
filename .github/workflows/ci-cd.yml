name: CI-CD

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

concurrency:
  group: trackway-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  packages: write

jobs:
  test:
    name: Test and Build
    runs-on:
      - self-hosted
      - Linux
      - X64
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache: true

      - name: Format check
        run: |
          if [ -n "$(gofmt -l .)" ]; then
            echo "gofmt check failed; run 'make format'"
            gofmt -l .
            exit 1
          fi

      - name: Lint
        run: go vet ./...

      - name: Typecheck
        run: go test -run '^$' ./...

      - name: Test
        run: go test ./...

      - name: Build
        run: go build ./...

      - name: Security
        run: |
          go run golang.org/x/vuln/cmd/govulncheck@latest ./...
          go run ./cmd/secretscan

  image:
    name: Build and Push Image
    runs-on:
      - self-hosted
      - Linux
      - X64
    needs:
      - test
    if: github.event_name != 'pull_request' && github.ref == 'refs/heads/main'
    outputs:
      image_latest: ${{ steps.meta.outputs.image_latest }}
      image_sha: ${{ steps.meta.outputs.image_sha }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Derive image names
        id: meta
        run: |
          set -euo pipefail
          owner_lower="$(echo "${GITHUB_REPOSITORY_OWNER}" | tr '[:upper:]' '[:lower:]')"
          image_base="ghcr.io/${owner_lower}/trackway"
          image_sha="${image_base}:${GITHUB_SHA}"
          image_latest="${image_base}:latest"
          echo "image_sha=${image_sha}" >> "${GITHUB_OUTPUT}"
          echo "image_latest=${image_latest}" >> "${GITHUB_OUTPUT}"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ steps.meta.outputs.image_sha }}
            ${{ steps.meta.outputs.image_latest }}

  deploy:
    name: Deploy over SSH
    runs-on:
      - self-hosted
      - Linux
      - X64
    needs:
      - image
    if: github.event_name != 'pull_request' && github.ref == 'refs/heads/main'
    env:
      DEPLOY_DIR: /opt/trackway
      TRACKWAY_CONFIG_PATH: /opt/trackway/config.json
      COMPOSE_PROJECT_NAME: trackway
      TRACKWAY_IMAGE: ${{ needs.image.outputs.image_latest }}

      TRACKWAY_BIND_IP: ${{ secrets.TRACKWAY_BIND_IP || '127.0.0.1' }}
      TRACKWAY_BIND_PORT: ${{ secrets.TRACKWAY_BIND_PORT || '8083' }}

      STORAGE_DRIVER: ${{ secrets.STORAGE_DRIVER || 'sqlite' }}
      SQLITE_PATH: ${{ secrets.SQLITE_PATH || '/data/trackway.db' }}
      SQLITE_RETENTION_DAYS: ${{ secrets.SQLITE_RETENTION_DAYS || '5' }}
      SQLITE_BUSY_TIMEOUT_MS: ${{ secrets.SQLITE_BUSY_TIMEOUT_MS || '5000' }}
      SQLITE_MAX_OPEN_CONNS: ${{ secrets.SQLITE_MAX_OPEN_CONNS || '1' }}
      SQLITE_MAX_IDLE_CONNS: ${{ secrets.SQLITE_MAX_IDLE_CONNS || '1' }}

      DEPLOY_SSH_HOST: ${{ secrets.DEPLOY_SSH_HOST || secrets.SSH_HOST }}
      DEPLOY_SSH_USER: ${{ secrets.DEPLOY_SSH_USER || secrets.SSH_USER || 'deploy' }}
      DEPLOY_SSH_PORT: ${{ secrets.DEPLOY_SSH_PORT || secrets.SSH_PORT || '22' }}
      DEPLOY_SSH_PRIVATE_KEY: ${{ secrets.DEPLOY_SSH_PRIVATE_KEY || secrets.SSH_PRIVATE_KEY }}
      DEPLOY_SSH_KNOWN_HOSTS: ${{ secrets.DEPLOY_SSH_KNOWN_HOSTS || secrets.SSH_KNOWN_HOSTS }}

      GHCR_USERNAME: ${{ github.actor }}
      GHCR_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      TRACKWAY_CONFIG_JSON: ${{ secrets.TRACKWAY_CONFIG_JSON }}
      TRACKWAY_CONFIG_JSON_B64: ${{ secrets.TRACKWAY_CONFIG_JSON_B64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate required secrets
        run: |
          set -euo pipefail
          if [ -z "${DEPLOY_SSH_HOST}" ]; then
            echo "Secret DEPLOY_SSH_HOST is required." >&2
            exit 1
          fi
          if [ -z "${DEPLOY_SSH_USER}" ]; then
            echo "Secret DEPLOY_SSH_USER is required." >&2
            exit 1
          fi
          if [ -z "${DEPLOY_SSH_PRIVATE_KEY}" ]; then
            echo "Secret DEPLOY_SSH_PRIVATE_KEY is required." >&2
            exit 1
          fi
          if [ -z "${GHCR_USERNAME}" ]; then
            echo "GHCR username is empty (github.actor)." >&2
            exit 1
          fi
          if [ -z "${GHCR_TOKEN}" ]; then
            echo "GITHUB_TOKEN is empty." >&2
            exit 1
          fi

      - name: Setup SSH key
        run: |
          set -euo pipefail
          mkdir -p "${HOME}/.ssh"
          chmod 700 "${HOME}/.ssh"
          printf '%s\n' "${DEPLOY_SSH_PRIVATE_KEY}" > "${HOME}/.ssh/id_trackway_deploy"
          chmod 600 "${HOME}/.ssh/id_trackway_deploy"

      - name: Setup known_hosts
        run: |
          set -euo pipefail
          port="${DEPLOY_SSH_PORT:-22}"
          if [ -n "${DEPLOY_SSH_KNOWN_HOSTS}" ]; then
            printf '%s\n' "${DEPLOY_SSH_KNOWN_HOSTS}" >> "${HOME}/.ssh/known_hosts"
          else
            ssh-keyscan -H -p "${port}" "${DEPLOY_SSH_HOST}" >> "${HOME}/.ssh/known_hosts"
          fi
          chmod 644 "${HOME}/.ssh/known_hosts"

      - name: Ensure remote directories
        run: |
          set -euo pipefail
          port="${DEPLOY_SSH_PORT:-22}"
          ssh -i "${HOME}/.ssh/id_trackway_deploy" -p "${port}" \
            -o BatchMode=yes -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes \
            "${DEPLOY_SSH_USER}@${DEPLOY_SSH_HOST}" \
            "mkdir -p '${DEPLOY_DIR}'"

      - name: Sync repo to server
        run: |
          set -euo pipefail
          port="${DEPLOY_SSH_PORT:-22}"
          rsync -az --delete \
            --exclude '.git' \
            --exclude 'config.json' \
            --exclude 'backups/' \
            -e "ssh -i ${HOME}/.ssh/id_trackway_deploy -p ${port} -o BatchMode=yes -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes" \
            "${GITHUB_WORKSPACE}/" "${DEPLOY_SSH_USER}@${DEPLOY_SSH_HOST}:${DEPLOY_DIR}/"

      - name: Deploy on server
        run: |
          set -euo pipefail
          port="${DEPLOY_SSH_PORT:-22}"

          ghcr_user_b64="$(printf '%s' "${GHCR_USERNAME}" | base64 -w0)"
          ghcr_token_b64="$(printf '%s' "${GHCR_TOKEN}" | base64 -w0)"
          runtime_config_json_b64="${TRACKWAY_CONFIG_JSON_B64}"
          if [ -z "${runtime_config_json_b64}" ] && [ -n "${TRACKWAY_CONFIG_JSON}" ]; then
            runtime_config_json_b64="$(printf '%s' "${TRACKWAY_CONFIG_JSON}" | base64 -w0)"
          fi

          ssh -i "${HOME}/.ssh/id_trackway_deploy" -p "${port}" \
            -o BatchMode=yes -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes \
            "${DEPLOY_SSH_USER}@${DEPLOY_SSH_HOST}" \
            "DEPLOY_DIR='${DEPLOY_DIR}' TRACKWAY_CONFIG_PATH='${TRACKWAY_CONFIG_PATH}' COMPOSE_PROJECT_NAME='${COMPOSE_PROJECT_NAME}' TRACKWAY_IMAGE='${TRACKWAY_IMAGE}' TRACKWAY_BIND_IP='${TRACKWAY_BIND_IP}' TRACKWAY_BIND_PORT='${TRACKWAY_BIND_PORT}' STORAGE_DRIVER='${STORAGE_DRIVER}' SQLITE_PATH='${SQLITE_PATH}' SQLITE_RETENTION_DAYS='${SQLITE_RETENTION_DAYS}' SQLITE_BUSY_TIMEOUT_MS='${SQLITE_BUSY_TIMEOUT_MS}' SQLITE_MAX_OPEN_CONNS='${SQLITE_MAX_OPEN_CONNS}' SQLITE_MAX_IDLE_CONNS='${SQLITE_MAX_IDLE_CONNS}' GHCR_USER_B64='${ghcr_user_b64}' GHCR_TOKEN_B64='${ghcr_token_b64}' TRACKWAY_CONFIG_JSON_B64='${runtime_config_json_b64}' bash -se" <<'REMOTE'
          set -euo pipefail

          decode_b64() {
            printf '%s' "$1" | base64 -d
          }

          ghcr_user="$(decode_b64 "${GHCR_USER_B64}")"
          ghcr_token="$(decode_b64 "${GHCR_TOKEN_B64}")"
          runtime_config_json_b64="${TRACKWAY_CONFIG_JSON_B64}"

          if [ -z "${runtime_config_json_b64}" ] && [ ! -s "${TRACKWAY_CONFIG_PATH}" ]; then
            echo "No runtime config provided and file is missing: ${TRACKWAY_CONFIG_PATH}" >&2
            echo "Set TRACKWAY_CONFIG_JSON(_B64) secret or provide config.json on server." >&2
            exit 1
          fi
          if [ -z "${runtime_config_json_b64}" ] && [ ! -r "${TRACKWAY_CONFIG_PATH}" ]; then
            echo "Config file exists but is not readable: ${TRACKWAY_CONFIG_PATH}" >&2
            echo "Fix on server: chmod 0644 ${TRACKWAY_CONFIG_PATH}" >&2
            exit 1
          fi
          if [ -n "${runtime_config_json_b64}" ] && [ ! -e "${TRACKWAY_CONFIG_PATH}" ]; then
            mkdir -p "$(dirname "${TRACKWAY_CONFIG_PATH}")"
            : > "${TRACKWAY_CONFIG_PATH}"
            chmod 0644 "${TRACKWAY_CONFIG_PATH}"
          fi

          export DOCKER_CONFIG="/tmp/trackway-docker-auth"
          cleanup_docker_auth() {
            rm -rf "${DOCKER_CONFIG}"
          }
          trap cleanup_docker_auth EXIT
          rm -rf "${DOCKER_CONFIG}"
          mkdir -p "${DOCKER_CONFIG}"
          printf '%s' "${ghcr_token}" | docker --config "${DOCKER_CONFIG}" login ghcr.io -u "${ghcr_user}" --password-stdin

          compose_with_env() {
            TRACKWAY_BIND_IP="${TRACKWAY_BIND_IP}" TRACKWAY_BIND_PORT="${TRACKWAY_BIND_PORT}" STORAGE_DRIVER="${STORAGE_DRIVER}" SQLITE_PATH="${SQLITE_PATH}" SQLITE_RETENTION_DAYS="${SQLITE_RETENTION_DAYS}" SQLITE_BUSY_TIMEOUT_MS="${SQLITE_BUSY_TIMEOUT_MS}" SQLITE_MAX_OPEN_CONNS="${SQLITE_MAX_OPEN_CONNS}" SQLITE_MAX_IDLE_CONNS="${SQLITE_MAX_IDLE_CONNS}" TRACKWAY_IMAGE="${TRACKWAY_IMAGE}" TRACKWAY_CONFIG_JSON_B64="${runtime_config_json_b64}" docker --config "${DOCKER_CONFIG}" compose \
              --project-name "${COMPOSE_PROJECT_NAME}" \
              -f "${DEPLOY_DIR}/docker-compose.yml" "$@"
          }

          # Hard cleanup of legacy ClickHouse artifacts from previous deployments.
          docker rm -f trackway-clickhouse >/dev/null 2>&1 || true
          docker rm -f "${COMPOSE_PROJECT_NAME}-clickhouse" >/dev/null 2>&1 || true
          docker rm -f "${COMPOSE_PROJECT_NAME}_clickhouse_1" >/dev/null 2>&1 || true
          docker volume rm trackway-clickhouse-data >/dev/null 2>&1 || true
          docker volume rm "${COMPOSE_PROJECT_NAME}-clickhouse-data" >/dev/null 2>&1 || true
          docker volume rm "${COMPOSE_PROJECT_NAME}_clickhouse-data" >/dev/null 2>&1 || true
          docker volume rm "${COMPOSE_PROJECT_NAME}_clickhouse_data" >/dev/null 2>&1 || true
          legacy_compose_volumes="$(docker volume ls -q --filter "label=com.docker.compose.project=${COMPOSE_PROJECT_NAME}" --filter "label=com.docker.compose.service=clickhouse")"
          if [ -n "${legacy_compose_volumes}" ]; then
            printf '%s\n' "${legacy_compose_volumes}" | xargs -r docker volume rm >/dev/null 2>&1 || true
          fi

          compose_with_env pull trackway
          compose_with_env up -d trackway --remove-orphans

          sleep 5
          trackway_container="$(compose_with_env ps -q trackway)"
          if [ -z "${trackway_container}" ]; then
            echo "Trackway container id not found after deploy." >&2
            compose_with_env ps
            compose_with_env logs --tail=120 trackway
            exit 1
          fi

          trackway_state="$(docker inspect --format '{{.State.Status}}' "${trackway_container}" 2>/dev/null || echo unknown)"
          if [ "${trackway_state}" != "running" ]; then
            echo "Trackway container is not running after deploy (state=${trackway_state})." >&2
            compose_with_env ps
            compose_with_env logs --tail=120 trackway
            exit 1
          fi

          echo "Deployment completed. Trackway container is running."
          REMOTE
