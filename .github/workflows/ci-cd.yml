name: CI-CD

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

concurrency:
  group: trackway-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  packages: write

jobs:
  test:
    name: Test and Build
    runs-on:
      - self-hosted
      - Linux
      - X64
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache: true

      - name: Run tests
        run: go test ./...

      - name: Build
        run: go build ./...

  image:
    name: Build and Push Image
    runs-on:
      - self-hosted
      - Linux
      - X64
    needs:
      - test
    if: github.event_name != 'pull_request' && github.ref == 'refs/heads/main'
    outputs:
      image_latest: ${{ steps.meta.outputs.image_latest }}
      image_sha: ${{ steps.meta.outputs.image_sha }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Derive image names
        id: meta
        run: |
          set -euo pipefail
          owner_lower="$(echo "${GITHUB_REPOSITORY_OWNER}" | tr '[:upper:]' '[:lower:]')"
          image_base="ghcr.io/${owner_lower}/trackway"
          image_sha="${image_base}:${GITHUB_SHA}"
          image_latest="${image_base}:latest"
          echo "image_sha=${image_sha}" >> "${GITHUB_OUTPUT}"
          echo "image_latest=${image_latest}" >> "${GITHUB_OUTPUT}"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ steps.meta.outputs.image_sha }}
            ${{ steps.meta.outputs.image_latest }}

  deploy:
    name: Deploy over SSH
    runs-on:
      - self-hosted
      - Linux
      - X64
    needs:
      - image
    if: github.event_name != 'pull_request' && github.ref == 'refs/heads/main'
    env:
      DEPLOY_DIR: /opt/trackway
      BACKUP_DIR: /opt/trackway/backups
      TRACKWAY_CONFIG_PATH: /opt/trackway/config.yaml
      COMPOSE_PROJECT_NAME: trackway
      BACKUP_KEEP: "30"
      TRACKWAY_IMAGE: ${{ needs.image.outputs.image_latest }}

      DEPLOY_SSH_HOST: ${{ secrets.DEPLOY_SSH_HOST || secrets.SSH_HOST }}
      DEPLOY_SSH_USER: ${{ secrets.DEPLOY_SSH_USER || secrets.SSH_USER || 'deploy' }}
      DEPLOY_SSH_PORT: ${{ secrets.DEPLOY_SSH_PORT || secrets.SSH_PORT || '22' }}
      DEPLOY_SSH_PRIVATE_KEY: ${{ secrets.DEPLOY_SSH_PRIVATE_KEY || secrets.SSH_PRIVATE_KEY }}
      DEPLOY_SSH_KNOWN_HOSTS: ${{ secrets.DEPLOY_SSH_KNOWN_HOSTS || secrets.SSH_KNOWN_HOSTS }}

      GHCR_USERNAME: ${{ github.actor }}
      GHCR_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      TRACKWAY_CONFIG_YAML: ${{ secrets.TRACKWAY_CONFIG_YAML }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate required secrets
        run: |
          set -euo pipefail
          if [ -z "${DEPLOY_SSH_HOST}" ]; then
            echo "Secret DEPLOY_SSH_HOST is required." >&2
            exit 1
          fi
          if [ -z "${DEPLOY_SSH_USER}" ]; then
            echo "Secret DEPLOY_SSH_USER is required." >&2
            exit 1
          fi
          if [ -z "${DEPLOY_SSH_PRIVATE_KEY}" ]; then
            echo "Secret DEPLOY_SSH_PRIVATE_KEY is required." >&2
            exit 1
          fi
          if [ -z "${GHCR_USERNAME}" ]; then
            echo "GHCR username is empty (github.actor)." >&2
            exit 1
          fi
          if [ -z "${GHCR_TOKEN}" ]; then
            echo "GITHUB_TOKEN is empty." >&2
            exit 1
          fi

      - name: Setup SSH key
        run: |
          set -euo pipefail
          mkdir -p "${HOME}/.ssh"
          chmod 700 "${HOME}/.ssh"
          printf '%s\n' "${DEPLOY_SSH_PRIVATE_KEY}" > "${HOME}/.ssh/id_trackway_deploy"
          chmod 600 "${HOME}/.ssh/id_trackway_deploy"

      - name: Setup known_hosts
        run: |
          set -euo pipefail
          port="${DEPLOY_SSH_PORT:-22}"
          if [ -n "${DEPLOY_SSH_KNOWN_HOSTS}" ]; then
            printf '%s\n' "${DEPLOY_SSH_KNOWN_HOSTS}" >> "${HOME}/.ssh/known_hosts"
          else
            ssh-keyscan -H -p "${port}" "${DEPLOY_SSH_HOST}" >> "${HOME}/.ssh/known_hosts"
          fi
          chmod 644 "${HOME}/.ssh/known_hosts"

      - name: Ensure remote directories
        run: |
          set -euo pipefail
          port="${DEPLOY_SSH_PORT:-22}"
          ssh -i "${HOME}/.ssh/id_trackway_deploy" -p "${port}" \
            -o BatchMode=yes -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes \
            "${DEPLOY_SSH_USER}@${DEPLOY_SSH_HOST}" \
            "mkdir -p '${DEPLOY_DIR}' '${BACKUP_DIR}'"

      - name: Sync repo to server
        run: |
          set -euo pipefail
          port="${DEPLOY_SSH_PORT:-22}"
          rsync -az --delete \
            --exclude '.git' \
            --exclude 'config.yaml' \
            --exclude 'backups/' \
            -e "ssh -i ${HOME}/.ssh/id_trackway_deploy -p ${port} -o BatchMode=yes -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes" \
            "${GITHUB_WORKSPACE}/" "${DEPLOY_SSH_USER}@${DEPLOY_SSH_HOST}:${DEPLOY_DIR}/"

      - name: Write runtime config from secret (optional)
        if: ${{ env.TRACKWAY_CONFIG_YAML != '' }}
        run: |
          set -euo pipefail
          port="${DEPLOY_SSH_PORT:-22}"
          config_b64="$(printf '%s' "${TRACKWAY_CONFIG_YAML}" | base64 -w0)"
          ssh -i "${HOME}/.ssh/id_trackway_deploy" -p "${port}" \
            -o BatchMode=yes -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes \
            "${DEPLOY_SSH_USER}@${DEPLOY_SSH_HOST}" \
            "umask 022 && printf '%s' '${config_b64}' | base64 -d > '${TRACKWAY_CONFIG_PATH}' && chmod 0644 '${TRACKWAY_CONFIG_PATH}'"

      - name: Deploy on server
        run: |
          set -euo pipefail
          port="${DEPLOY_SSH_PORT:-22}"
          ghcr_user_b64="$(printf '%s' "${GHCR_USERNAME}" | base64 -w0)"
          ghcr_token_b64="$(printf '%s' "${GHCR_TOKEN}" | base64 -w0)"
          ssh -i "${HOME}/.ssh/id_trackway_deploy" -p "${port}" \
            -o BatchMode=yes -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes \
            "${DEPLOY_SSH_USER}@${DEPLOY_SSH_HOST}" \
            "DEPLOY_DIR='${DEPLOY_DIR}' BACKUP_DIR='${BACKUP_DIR}' TRACKWAY_CONFIG_PATH='${TRACKWAY_CONFIG_PATH}' COMPOSE_PROJECT_NAME='${COMPOSE_PROJECT_NAME}' BACKUP_KEEP='${BACKUP_KEEP}' TRACKWAY_IMAGE='${TRACKWAY_IMAGE}' GHCR_USER_B64='${ghcr_user_b64}' GHCR_TOKEN_B64='${ghcr_token_b64}' bash -se" <<'REMOTE'
          set -euo pipefail

          if [ ! -s "${TRACKWAY_CONFIG_PATH}" ]; then
            echo "Missing config file at ${TRACKWAY_CONFIG_PATH}" >&2
            echo "Create it manually on server or set TRACKWAY_CONFIG_YAML secret." >&2
            exit 1
          fi
          if [ ! -r "${TRACKWAY_CONFIG_PATH}" ]; then
            echo "Config file exists but is not readable: ${TRACKWAY_CONFIG_PATH}" >&2
            echo "Fix on server: chmod 0644 ${TRACKWAY_CONFIG_PATH}" >&2
            exit 1
          fi

          ghcr_user="$(printf '%s' "${GHCR_USER_B64}" | base64 -d)"
          ghcr_token="$(printf '%s' "${GHCR_TOKEN_B64}" | base64 -d)"

          # Read ClickHouse values from runtime config so DB and app always use the same credentials.
          extract_clickhouse_config_value() {
            local key="$1"
            local config_path="$2"
            awk -v target_key="${key}" '
              function trim(s) {
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", s)
                return s
              }
              function indent_len(s,   m) {
                m = match(s, /[^[:space:]]/)
                if (m == 0) {
                  return length(s)
                }
                return m - 1
              }
              {
                line = $0
                sub(/\r$/, "", line)
                raw_indent = indent_len(line)
                trimmed = trim(line)

                if (trimmed == "" || trimmed ~ /^#/) {
                  next
                }

                if (!in_storage) {
                  if (raw_indent == 0 && trimmed ~ /^storage:[[:space:]]*$/) {
                    in_storage = 1
                    storage_indent = raw_indent
                    in_clickhouse = 0
                  }
                  next
                }

                if (raw_indent <= storage_indent && trimmed !~ /^storage:[[:space:]]*$/) {
                  in_storage = 0
                  in_clickhouse = 0
                  next
                }

                if (!in_clickhouse) {
                  if (trimmed ~ /^clickhouse:[[:space:]]*$/) {
                    in_clickhouse = 1
                    clickhouse_indent = raw_indent
                  }
                  next
                }

                if (raw_indent <= clickhouse_indent) {
                  in_clickhouse = 0
                  next
                }

                if (trimmed ~ ("^" target_key ":[[:space:]]*")) {
                  value = trimmed
                  sub("^" target_key ":[[:space:]]*", "", value)
                  value = trim(value)

                  if (value ~ /^".*"$/) {
                    sub(/^"/, "", value)
                    sub(/"$/, "", value)
                  } else if (value ~ /^'\''.*'\''$/) {
                    sub(/^'\''/, "", value)
                    sub(/'\''$/, "", value)
                  } else {
                    sub(/[[:space:]]+#.*$/, "", value)
                  }

                  value = trim(value)
                  print value
                  found = 1
                  exit
                }
              }
              END {
                if (!found) {
                  print ""
                }
              }
            ' "${config_path}"
          }

          clickhouse_db="$(extract_clickhouse_config_value database "${TRACKWAY_CONFIG_PATH}")"
          clickhouse_user="$(extract_clickhouse_config_value username "${TRACKWAY_CONFIG_PATH}")"
          clickhouse_password="$(extract_clickhouse_config_value password "${TRACKWAY_CONFIG_PATH}")"
          if [ -z "${clickhouse_db}" ]; then
            clickhouse_db="trackway"
          fi
          if [ -z "${clickhouse_user}" ]; then
            clickhouse_user="default"
          fi
          echo "Resolved ClickHouse config from ${TRACKWAY_CONFIG_PATH}: db='${clickhouse_db}', user='${clickhouse_user}', password_length=${#clickhouse_password}"

          export DOCKER_CONFIG="/tmp/trackway-docker-auth"
          cleanup_docker_auth() {
            rm -rf "${DOCKER_CONFIG}"
          }
          trap cleanup_docker_auth EXIT
          rm -rf "${DOCKER_CONFIG}"
          mkdir -p "${DOCKER_CONFIG}"
          printf '%s' "${ghcr_token}" | docker --config "${DOCKER_CONFIG}" login ghcr.io -u "${ghcr_user}" --password-stdin

          compose_with_env() {
            CLICKHOUSE_DB="${clickhouse_db}" CLICKHOUSE_USER="${clickhouse_user}" CLICKHOUSE_PASSWORD="${clickhouse_password}" TRACKWAY_IMAGE="${TRACKWAY_IMAGE}" docker --config "${DOCKER_CONFIG}" compose \
              --project-name "${COMPOSE_PROJECT_NAME}" \
              -f "${DEPLOY_DIR}/docker-compose.yml" "$@"
          }

          wait_clickhouse_healthy() {
            clickhouse_container="$(compose_with_env ps -q clickhouse)"
            if [ -z "${clickhouse_container}" ]; then
              echo "Failed to resolve clickhouse container id." >&2
              compose_with_env logs --tail=200 clickhouse
              return 1
            fi

            clickhouse_ready=0
            for _ in $(seq 1 90); do
              health_status="$(docker inspect --format '{{if .State.Health}}{{.State.Health.Status}}{{else}}no-healthcheck{{end}}' "${clickhouse_container}" 2>/dev/null || echo unknown)"
              if [ "${health_status}" = "healthy" ]; then
                clickhouse_ready=1
                break
              fi
              if [ "${health_status}" = "unhealthy" ] || [ "${health_status}" = "exited" ] || [ "${health_status}" = "dead" ]; then
                echo "ClickHouse is ${health_status}." >&2
                compose_with_env ps
                compose_with_env logs --tail=200 clickhouse
                return 1
              fi
              sleep 2
            done

            if [ "${clickhouse_ready}" -ne 1 ]; then
              echo "ClickHouse did not become healthy in time." >&2
              compose_with_env ps
              compose_with_env logs --tail=200 clickhouse
              return 1
            fi
            return 0
          }

          validate_clickhouse_auth() {
            docker exec "${clickhouse_container}" clickhouse-client \
              --host=127.0.0.1 \
              --user="${clickhouse_user}" \
              --password="${clickhouse_password}" \
              --query="SELECT 1" >/dev/null 2>&1
          }

          validate_clickhouse_auth_without_password() {
            docker exec "${clickhouse_container}" clickhouse-client \
              --host=127.0.0.1 \
              --user="${clickhouse_user}" \
              --query="SELECT 1" >/dev/null 2>&1
          }

          set_clickhouse_user_password() {
            if [ -z "${clickhouse_password}" ]; then
              return 0
            fi
            case "${clickhouse_user}" in
              ''|*[!A-Za-z0-9_]*)
                echo "Unsupported ClickHouse username for automated password repair: ${clickhouse_user}" >&2
                return 1
                ;;
            esac

            escaped_password="$(printf '%s' "${clickhouse_password}" | sed "s/'/''/g")"
            docker exec "${clickhouse_container}" clickhouse-client \
              --host=127.0.0.1 \
              --user="${clickhouse_user}" \
              --query="ALTER USER ${clickhouse_user} IDENTIFIED BY '${escaped_password}'"
          }

          reset_clickhouse_access_metadata() {
            local volume_name
            volume_name="$(docker inspect --format '{{range .Mounts}}{{if eq .Destination "/var/lib/clickhouse"}}{{.Name}}{{end}}{{end}}' "${clickhouse_container}")"
            if [ -z "${volume_name}" ]; then
              echo "Cannot detect ClickHouse data volume." >&2
              return 1
            fi

            echo "Resetting ClickHouse access metadata in volume ${volume_name}..."
            compose_with_env stop clickhouse
            docker run --rm \
              -v "${volume_name}:/var/lib/clickhouse" \
              alpine:3.20 \
              sh -euc 'rm -rf /var/lib/clickhouse/access/*'
            compose_with_env up -d --force-recreate clickhouse
            wait_clickhouse_healthy
          }

          bash "${DEPLOY_DIR}/scripts/backup-clickhouse.sh" "${DEPLOY_DIR}" "${BACKUP_DIR}"

          compose_with_env up -d --force-recreate clickhouse
          wait_clickhouse_healthy

          if ! validate_clickhouse_auth; then
            repaired=0

            if [ -z "${clickhouse_password}" ]; then
              echo "Configured ClickHouse password is empty (password_length=0), but auth failed." >&2
              echo "If TRACKWAY_CONFIG_YAML secret is set, it overwrites /opt/trackway/config.yaml on every deploy." >&2
              echo "Update TRACKWAY_CONFIG_YAML with correct storage.clickhouse.password or remove the secret." >&2
            fi

            if [ -n "${clickhouse_password}" ] && validate_clickhouse_auth_without_password; then
              echo "ClickHouse allows login without password. Applying password from config..." >&2
              if set_clickhouse_user_password && validate_clickhouse_auth; then
                repaired=1
              fi
            fi

            if [ "${repaired}" -ne 1 ]; then
              echo "ClickHouse rejects configured credentials. Trying one-time access metadata reset..." >&2
              if reset_clickhouse_access_metadata && validate_clickhouse_auth; then
                repaired=1
              fi
            fi

            if [ "${repaired}" -ne 1 ]; then
              echo "ClickHouse still rejects configured credentials after automated repair attempts." >&2
              compose_with_env ps
              compose_with_env logs --tail=200 clickhouse
              exit 1
            fi
          fi

          compose_with_env pull trackway
          compose_with_env up -d trackway --remove-orphans

          sleep 5
          trackway_container="$(compose_with_env ps -q trackway)"
          if [ -z "${trackway_container}" ]; then
            echo "Trackway container id not found after deploy." >&2
            compose_with_env ps
            compose_with_env logs --tail=120 trackway
            exit 1
          fi
          trackway_state="$(docker inspect --format '{{.State.Status}}' "${trackway_container}" 2>/dev/null || echo unknown)"
          if [ "${trackway_state}" != "running" ]; then
            echo "Trackway container is not running after deploy (state=${trackway_state})." >&2
            compose_with_env ps
            compose_with_env logs --tail=120 trackway
            exit 1
          fi
          echo "Deployment completed. Trackway container is running."
          exit 0
          REMOTE
